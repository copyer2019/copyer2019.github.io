<!DOCTYPE html>
<html>
  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="author" content="Dong Yuanxin">
  
  
  <title>贪心算法 | 七月飞雪</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="编程,算法,编程,电脑,算法,">
  

  
  <meta name="description" content="贪心算法总结贪心算法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。">

  

  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>
  

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":true,"count":true},
    welcome: {"enable":false,"interval":30},
    start_time: "2018-02-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "Dong Yuanxin",
    share: {"twitter":true,"facebook":true,"weibo":true,"qq":true,"wechat":true},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">GODBMW</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 安静写些东西</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/friends/" target="_self">友链</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/dongyuanxin/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/friends/" target="_self">
            友链
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2017-12-29
    </span>
    
      <span>
        | <a href="/categories/编程/"><i class="fa fa-bookmark"></i>编程</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    贪心算法
  </h1>
  
  <article class="passage-article">
    <p></p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><ol>
<li>建立数学模型来描述问题；</li>
<li>把求解的问题分成若干个子问题；</li>
<li>对每一子问题求解，得到子问题的局部最优解；</li>
<li>把子问题的解局部最优解合成原来解问题的一个解。</li>
</ol>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><ol>
<li>从问题的某个初始解出发。</li>
<li>采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。</li>
<li>将所有部分解综合起来，得到问题的最终解。</li>
</ol>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="实例-1-背包问题"><a href="#实例-1-背包问题" class="headerlink" title="实例 1 背包问题"></a>实例 1 背包问题</h2><ul>
<li><p>问题描述有一个背包，背包容量是 M=150。有 7 个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-f0413127c4754248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/459" alt="img"></p>
</li>
<li><p>问题分析</p>
<p>​</p>
<p>1.目标函数： ∑pi 最大，使得装入背包中的所有物品 pi 的价值加起来最大。</p>
<p>​</p>
<p>2.约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</p>
<p>​</p>
<p>3.贪心策略：</p>
<ul>
<li>选择价值最大的物品</li>
<li>选择价值最大的物品</li>
<li>选择单位重量价值最大的物品有三个物品 A,B,C，其重量分别为{30,10,20}，价值分别为{60,30,80}，背包的容量为 50，分别应用三种贪心策略装入背包的物品和获得的价值如下图所示：</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-78c7905f18412c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507" alt="img"></p>
<p>三种策略</p>
<ul>
<li>算法设计：</li>
</ul>
<ol>
<li>计算出每个物品单位重量的价值</li>
<li>按单位价值从大到小将物品排序</li>
<li>根据背包当前所剩容量选取物品</li>
<li>如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int w;</span><br><span class="line">    int v;</span><br><span class="line">    double avg;</span><br><span class="line">&#125;P;</span><br><span class="line">bool cmp(P a,P b)&#123;</span><br><span class="line">    return a.avg&gt;b.avg;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    P *p;</span><br><span class="line">    int n,i,m;//n 物品个数 m背包容量</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        p=new P[n];</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;p[i].w&gt;&gt;p[i].v;</span><br><span class="line">            p[i].avg=p[i].v/p[i].w*1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n,cmp);</span><br><span class="line">        int maxvalue=0;</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(p[i].w&lt;=m)&#123;</span><br><span class="line">                m-=p[i].w;</span><br><span class="line">                maxvalue+=p[i].v;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;maxvalue&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行结果</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-bd56564c206c2060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/358" alt="img"></p>
</li>
</ul>
<h2 id="实例-2-活动安排问题"><a href="#实例-2-活动安排问题" class="headerlink" title="实例 2 活动安排问题"></a>实例 2 活动安排问题</h2><ul>
<li>问题描述：设有 n 个活动的集合 E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 si 和一个结束时间 fi,且 si &lt;fi 。要求设计程序，使得安排的活动最多。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-86b31fdeff88b7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>(ps:活动结束时间按从小到大排序)</p>
<ul>
<li>问题分析：活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有 n 个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 starti 和一个结束时间 endi，且 starti&lt;endi。如选择了活动 i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动 i 与活动 j 是相容的。也就是说，当 startj≥endi 或 starti≥endj 时，活动 i 与活动 j 相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。</li>
<li>算法设计：若被检查的活动 i 的开始时间 starti 小于最近选择的活动 j 的结束时间 endj，则不选择活动 i，否则选择活动 i 加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需 O(n)的时间安排 n 个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用 O(nlogn)的时间重排。</li>
<li>代码实现：代码 1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct actime&#123;</span><br><span class="line">    int start,finish;</span><br><span class="line">&#125;act[1002];</span><br><span class="line">bool cmp(actime a,actime b)&#123;</span><br><span class="line">    return a.finish&lt;b.finish;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,n,t,total;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;//活动的个数</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;act[i].start&gt;&gt;act[i].finish;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(act,act+n,cmp);//按活动结束时间从小到大排序</span><br><span class="line">        t=-1;</span><br><span class="line">        total=0;</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(t&lt;=act[i].start)&#123;</span><br><span class="line">                total++;</span><br><span class="line">                t=act[i].finish;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行结果 1</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-7f69c2dc3fa512e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/489" alt="img"></p>
</li>
</ul>
<p>代码 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class Type&gt;</span><br><span class="line">void GreedySelector(int n, Type s[], Type f[], bool A[]);</span><br><span class="line"></span><br><span class="line">const int N = 11;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //下标从1开始,存储活动开始时间</span><br><span class="line">    int s[] = &#123;0,1,3,0,5,3,5,6,8,8,2,12&#125;;</span><br><span class="line"></span><br><span class="line">    //下标从1开始,存储活动结束时间</span><br><span class="line">    int f[] = &#123;0,4,5,6,7,8,9,10,11,12,13,14&#125;;</span><br><span class="line"></span><br><span class="line">    bool A[N+1];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;各活动的开始时间,结束时间分别为：&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;s[i]&lt;&lt;&quot;,&quot;&lt;&lt;f[i]&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    GreedySelector(N,s,f,A);</span><br><span class="line">    cout&lt;&lt;&quot;最大相容活动子集为：&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(A[i])&#123;</span><br><span class="line">            cout&lt;&lt;&quot;[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;s[i]&lt;&lt;&quot;,&quot;&lt;&lt;f[i]&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class Type&gt;</span><br><span class="line">void GreedySelector(int n, Type s[], Type f[], bool A[])</span><br><span class="line">&#123;</span><br><span class="line">    A[1]=true;</span><br><span class="line">    int j=1;//记录最近一次加入A中的活动</span><br><span class="line"></span><br><span class="line">    for (int i=2;i&lt;=n;i++)//依次检查活动i是否与当前已选择的活动相容</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i]&gt;=f[j])</span><br><span class="line">        &#123;</span><br><span class="line">            A[i]=true;</span><br><span class="line">            j=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            A[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果 2</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-fdab36968693b0f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<h2 id="实例-3-最小生成树（克鲁斯卡尔算法）"><a href="#实例-3-最小生成树（克鲁斯卡尔算法）" class="headerlink" title="实例 3 最小生成树（克鲁斯卡尔算法）"></a>实例 3 最小生成树（克鲁斯卡尔算法）</h2><ul>
<li>问题描述</li>
</ul>
<blockquote>
<p>求一个连通无向图的最小生成树的代价（图边权值为正整数）。</p>
</blockquote>
<p>输入</p>
<blockquote>
<p>第一行是一个整数 N（1&lt;=N&lt;=20），表示有多少个图需要计算。以下有 N 个图，第 i 图的第一行是一个整数 M（1&lt;=M&lt;=50），表示图的顶点数，第 i 图的第 2 行至 1+M 行为一个 M*M 的二维矩阵，其元素 ai,j 表示图的 i 顶点和 j 顶点的连接情况，如果 ai,j=0，表示 i 顶点和 j 顶点不相连；如果 ai,j&gt;0，表示 i 顶点和 j 顶点的连接权值。</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>每个用例，用一行输出对应图的最小生成树的代价。</p>
</blockquote>
<p>样例输入</p>
<blockquote>
<p>1<br>6<br>0 6 1 5 0 0<br>6 0 5 0 3 0<br>1 5 0 5 6 4<br>5 0 5 0 0 2<br>0 3 6 0 0 6<br>0 0 4 2 6 0</p>
</blockquote>
<p>样例输出</p>
<blockquote>
<p>15</p>
</blockquote>
<ul>
<li><p>Kruskal 算法简述假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1 条边为止。</p>
</li>
<li><p>模拟过程：</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-32e164789d15c188.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>模拟过程</p>
</li>
<li><p>算法难点：（1）边的选择要求从小到大选择，则开始显然要对边进行升序排序。（2）选择的边是否需要，则从判断该边加入后是否构成环入手。</p>
</li>
<li><p>算法设计：（1）对边升序排序在此采用链式结构，通过插入排序完成。每一结点存放一条边的左右端点序号、权值及后继结点指针（2）边的加入是否构成环一开始假定各顶点分别为一组，其组号为端点序号。选择某边后，看其两个端点是否在同一组中，即所在组号是否相同，如果是，表示构成了环，则舍去。 如果两个端点所在的组不同，则表示可以加入，则将该边两端的组合并成同一组。</p>
</li>
<li><p>代码实现：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line"> int l;</span><br><span class="line"> int r;</span><br><span class="line"> int len;</span><br><span class="line"> node *next;</span><br><span class="line">&#125;;</span><br><span class="line">void insert(node *&amp;h,node *p)   //指针插入排序</span><br><span class="line">&#123;</span><br><span class="line"> node *q=h;</span><br><span class="line"> while(q-&gt;next &amp;&amp; q-&gt;next-&gt;len &lt;= p-&gt;len)</span><br><span class="line"> &#123;</span><br><span class="line">  q=q-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> p-&gt;next=q-&gt;next;</span><br><span class="line"> q-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">// freopen(&quot;001.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line"> node *h,*p;</span><br><span class="line"> int n,m,x,temp;</span><br><span class="line"> int *a;</span><br><span class="line"> int i,j;</span><br><span class="line"> int sum;</span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"> while(n--)</span><br><span class="line"> &#123;</span><br><span class="line">  sum=0;</span><br><span class="line">  cin&gt;&gt;m;</span><br><span class="line">  a=new int[m+1];</span><br><span class="line">  for (i=1;i&lt;=m;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   a[i]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  h=new node;</span><br><span class="line">  p=h;</span><br><span class="line">  p-&gt;next=NULL;</span><br><span class="line">  for (i=1;i&lt;=m;i++)</span><br><span class="line">   for (j=1;j&lt;=m;j++)</span><br><span class="line">   &#123;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    if (i&gt;j &amp;&amp; x!=0)</span><br><span class="line">    &#123;</span><br><span class="line">     p=new node;</span><br><span class="line">     p-&gt;l=i;</span><br><span class="line">     p-&gt;r=j;</span><br><span class="line">     p-&gt;len=x;</span><br><span class="line">     p-&gt;next=NULL;</span><br><span class="line">     insert(h,p);   //调用插入排序</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          p=h-&gt;next;</span><br><span class="line">   while (p)</span><br><span class="line">   &#123;</span><br><span class="line">    if (a[p-&gt;l]!=a[p-&gt;r])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">     sum+=p-&gt;len;</span><br><span class="line">     temp=a[p-&gt;l];</span><br><span class="line">     for(i=1;i&lt;=m;i++)</span><br><span class="line">      if (a[i]==temp)</span><br><span class="line">      &#123;</span><br><span class="line">       a[i]=a[p-&gt;r];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   /*   可以测试程序工作是否正常</span><br><span class="line">   p=h-&gt;next;</span><br><span class="line">   while(p)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;p-&gt;l&lt;&lt;&apos;:&apos;;cout&lt;&lt;p-&gt;r&lt;&lt;&apos; &apos;;</span><br><span class="line">    cout&lt;&lt;p-&gt;len&lt;&lt;&quot;   &quot;;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   */</span><br><span class="line">   cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行结果</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-a014db737d1ae27d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/418" alt="img"></p>
<p>image.png</p>
</li>
</ul>
<h2 id="实例-4-hdu1050-Moving-Tables"><a href="#实例-4-hdu1050-Moving-Tables" class="headerlink" title="实例 4 hdu1050-Moving Tables"></a>实例 4 hdu1050-Moving Tables</h2><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>在一个狭窄的走廊里将桌子从一个房间移动到另一个房间，走廊的宽度只能允许一个桌子通过。给出 t，表示有 t 组测试数据。再给出 n，表示要移动 n 个桌子。n 下面有 n 行，每行两个数字，表示将桌子从 a 房间移到 b 房间。走廊的分布图如一图所示，每移动一个桌子到达目的地房间需要花 10 分钟，问移动 n 个桌子所需要的时间。</p>
</blockquote>
<ul>
<li>输入</li>
</ul>
<blockquote>
<p>3<br>4<br>10 20<br>30 40<br>50 60<br>70 80<br>2<br>1 3<br>2 200<br>3<br>10 100<br>20 80<br>30 50</p>
</blockquote>
<ul>
<li>输出</li>
</ul>
<blockquote>
<p>10<br>20<br>30</p>
</blockquote>
<ul>
<li>解题思路若移动多个桌子时，所需要经过的走廊没有重合处，即可以同时移动。若有一段走廊有 m 个桌子都要经过，一次只能经过一个桌子，则需要 m*10 的时间移动桌子。 设一个数组，下标值即为房间号。桌子经过房间时，该房间号为下标对应的数组值即加 10。最后找到最大的数组值，即为移动完桌子需要的最短时间。(以上为代码 2，代码 3 同这个思想)<br>注意：</li>
</ul>
<ol>
<li><p>可能出发位置比目的地房间大,无论大小，我们都可以看做从小的房间移动到大的房间</p>
</li>
<li><p>出发房间为偶数则减一，结束房间为奇数则加一</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-9c97005356ed25db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>​</p>
<p>我们首先输入每次移动的出发和结束房间，然后按每次移动的出发房间从小到大排序，然后直至所有的房间移动完毕。（代码 1 的解释）</p>
</li>
</ol>
<ul>
<li>代码 1（我自己感觉不是贪心算法，属于暴力破解吧，大家酌情考虑）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct table&#123;</span><br><span class="line">    int from,to;</span><br><span class="line">    bool flag;//记录改房间是否被访问过</span><br><span class="line">&#125;moving[205];</span><br><span class="line"></span><br><span class="line">bool cmp(table a,table b)&#123;</span><br><span class="line">    return a.from&lt;b.from;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,T,n;//T代表测试实例个数，n代表每个测试下的table个数</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;moving[i].from&gt;&gt;moving[i].to;</span><br><span class="line">            if(moving[i].from &gt; moving[i].to)</span><br><span class="line">            &#123;</span><br><span class="line">                int temp = moving[i].from;</span><br><span class="line">                moving[i].from = moving[i].to;</span><br><span class="line">                moving[i].to = temp;</span><br><span class="line">            &#125;//可能出发位置比目的地房间大,无论大小，我们都可以看做从小的房间移动到大的房间</span><br><span class="line">            if(moving[i].from%2==0)&#123;//考虑实际情况，出发房间为偶数是减一，可参照题中给出的图一</span><br><span class="line">                moving[i].from--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(moving[i].to%2==1)&#123;//考虑实际情况，结束房间为奇数是加一，</span><br><span class="line">                moving[i].to++;</span><br><span class="line">            &#125;</span><br><span class="line">            moving[i].flag=false;//初始化房间未被访问过</span><br><span class="line">        &#125;</span><br><span class="line">        sort(moving,moving+n,cmp);//将所有table按出发房间从小到大排序;</span><br><span class="line">        bool completion=false;//是否所有的table移动结束</span><br><span class="line">        int cnt=-1,priorTo;//priorTo 记录前一个table移动结束的房间</span><br><span class="line">        while(!completion)&#123;</span><br><span class="line">            completion=true;</span><br><span class="line">            cnt++;</span><br><span class="line">            priorTo=0;</span><br><span class="line">            for(i=0;i&lt;n;i++)&#123;//每一轮将可以同时移动的table全部移动完：比如2-&gt;5,6-&gt;10，因为他们没有共用走廊</span><br><span class="line">                if(!moving[i].flag&amp;&amp;moving[i].from&gt;priorTo)&#123;</span><br><span class="line">                    moving[i].flag=true;//标记当前table已经移动完毕</span><br><span class="line">                    priorTo=moving[i].to;</span><br><span class="line">                    completion=false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cnt*10&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码 1 运行结果</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-69ea5abafe7cfc26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/560" alt="img"></p>
</li>
<li><p>代码 2</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,n,count[410],i,start,end,k;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        memset(count,0,sizeof(count));</span><br><span class="line">        while(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;start,&amp;end);</span><br><span class="line">            if(start&gt;end)//可能出发位置比目的地房间大。</span><br><span class="line">            &#123;            //无论大小，我们都可以看做从小的房间移动到大的房间</span><br><span class="line">                k=start;</span><br><span class="line">                start=end;</span><br><span class="line">                end=k;</span><br><span class="line">            &#125;</span><br><span class="line">            if(start%2==0)//考虑实际情况，出发房间为偶数是减一，可参照题中给出的图一</span><br><span class="line">               start-=1;</span><br><span class="line">            if(end%2==1)//目的地房间为奇数时加一</span><br><span class="line">               end+=1;</span><br><span class="line">            for(i=start;i&lt;=end;++i)</span><br><span class="line">               count[i]+=10;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,*max_element(count,count+400));//STL中寻找数列最大值函数</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码 3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define MAXN 500</span><br><span class="line">using namespace std;</span><br><span class="line">struct temp&#123;</span><br><span class="line">    int be,en;</span><br><span class="line">&#125;;</span><br><span class="line">bool comp(temp a,temp b)&#123;</span><br><span class="line">    return a.be&lt;b.be;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    temp my[MAXN];</span><br><span class="line">    int m,n,i;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        i=0;</span><br><span class="line">        int a,b,j;</span><br><span class="line">        while(i&lt;n)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            if(a&gt;b)a^=b^=a^=b;</span><br><span class="line">            my[i].be=(a+1)/2;</span><br><span class="line">            my[i++].en=(b+1)/2;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(my,my+n,comp);</span><br><span class="line">        int s=0,out=n,t=0;</span><br><span class="line">        int aa[203];</span><br><span class="line">        memset(aa,0,sizeof(aa));</span><br><span class="line">       for(i=0;i&lt;n;++i)&#123;</span><br><span class="line">            for(j=my[i].be;j&lt;=my[i].en;++j)aa[j]++;</span><br><span class="line">       &#125;</span><br><span class="line">       sort(aa,aa+200);</span><br><span class="line">        cout&lt;&lt;aa[199]*10&lt;&lt;&apos;\12&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本思路"><span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法实现"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实例分析"><span class="toc-text">实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实例-1-背包问题"><span class="toc-text">实例 1 背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例-2-活动安排问题"><span class="toc-text">实例 2 活动安排问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例-3-最小生成树（克鲁斯卡尔算法）"><span class="toc-text">实例 3 最小生成树（克鲁斯卡尔算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例-4-hdu1050-Moving-Tables"><span class="toc-text">实例 4 hdu1050-Moving Tables</span></a></li></ol></li></ol>
  </div>
</aside>
  
    <aside class="passage-copyright">
      <div>本文作者: 董沅鑫</div>
      
        <div>
          原文链接: 
          <a href target="_blank">https://copyer2019.github.io/20171229/how-are-you.html</a>
        </div>
      
      <div>
        版权声明: 本博客所有文章除特别声明外, 均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议. 转载请注明出处!
      </div>
    </aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/编程/"><i class="fa fa-tags"></i>编程</a>
     
      <a href="/tags/电脑/"><i class="fa fa-tags"></i>电脑</a>
     
      <a href="/tags/算法/"><i class="fa fa-tags"></i>算法</a>
    
    </div>
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">博客推荐</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/" target="_blank">GodBMW</a>
          </span>
        
          <span class="site-footer-item">
            <a href="http://ruanyifeng.com/" target="_blank">阮一峰的个人网站</a>
          </span>
        
      </div>
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">系列教程</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/categories/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" target="_blank">webpack4系列教程</a>
          </span>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/design-patterns/" target="_blank">设计模式手册</a>
          </span>
        
      </div>
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">抓到我</h5>
        
          <span class="site-footer-item">
            <a href="https://juejin.im/user/5b91fcf06fb9a05d3c7fd4a5" target="_blank">掘金</a>
          </span>
        
          <span class="site-footer-item">
            <a href="https://segmentfault.com/" target="_blank">思否</a>
          </span>
        
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: yuanxin.me@gmail.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
        
          <div>
            <img src="/images/wechat.png" alt="WeChat">
            
              <p>WeChat</p>
            
          </div>
        
          <div>
            <img src="/images/alipay.png" alt="AliPay">
            
              <p>AliPay</p>
            
          </div>
        
      </div>
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/20171229/cloudsim-configuration.html" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/20171227/using-mobile-phones-for-so-long.html" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    <a href="javascript:void(0);" id="site-reward">
      <i class="fa fa-thumbs-up"></i>
    </a>
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
    <a id="share-btn-twitter" href="javascript:void(0);" target="_blank">
      <i class="fa fa-twitter"></i>
    </a>
  
  
    <a id="share-btn-facebook" href="javascript:void(0);" target="_blank">
      <i class="fa fa-facebook"></i>
    </a>
  
  
    <a id="share-btn-weibo" href="javascript:void(0);" target="_blank">
      <i class="fa fa-weibo"></i>
    </a>
  
  
    <a id="share-btn-qq" href="javascript:void(0);" target="_blank">
      <i class="fa fa-qq"></i>
    </a>
  
  
    <a id="share-btn-wechat" href="javascript:void(0);" target="_blank">
      <i class="fa fa-wechat"></i>
    </a>
  
</div>
    





    
  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/live2d-widget","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>